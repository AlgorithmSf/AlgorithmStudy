# 문제 풀이

## [Baekjoon] 15683\_감시

### 문제 링크 : [https://www.acmicpc.net/problem/17135](https://www.acmicpc.net/problem/17135)

### 알고리즘 : DFS

### 풀이방법

- cctv마다 회전했을 때 바라보는 경우가 다양하고 불규칙적이어서
- 상, 우, 좌, 하 를 바라보는 각각의 경우를 리스트로 정의했다
- 입력받은 배열에서 1~5사이 값을 찾아 cctv_list에 추가하고, 이 리스트를 DFS한다.
- depth(시야범위를 적용한 cctv개수) == 전체 cctv 개수이면 2차원 배열에서 0의 개수를 카운트(사각지대 개수)
- 아직 모든 cctv의 시야범위를 적용하지 않았다면 cctv_list[depth]번 cctv의 시야범위 적용
  
### 이슈사항
- python 특유의 call-by-ref방식 때문에 오류를 한참동안 찾지 못했다.
- 매번 dfs동작마다 call-by-value를 위해 2차원 배열을 DeepCopy했는데 의외로 시간내에 동작했다.

---

# 문제 풀이

## [Baekjoon] 17135_캐슬디펜스

### 문제 링크 : [https://www.acmicpc.net/problem/17135](https://www.acmicpc.net/problem/17135)

### 알고리즘 : 완전탐색

### 풀이방법

- 궁수의 모든 배치 경우의수에 대하여 디펜스를 수행
- 디펜스 알고리즘
1. 공격할 궁수 선정
2. 모든 적에 대한 사거리 계산
3. 제일 가까운 적 타겟팅
4. 위 과정을 반복하여 모든 궁수가 적을 타겟팅하면 동시에 적을 죽임
5. 적이 한칸씩 몰려옴

### 이슈사항
- 궁수가 공격할 대상을 탐색할 때 열(j)이 왼쪽(0)에서 오른쪽(M)으로 이동하기 때문에
- 사거리가 같으면 왼쪽 적을 공격한다는 조건에 대해 깊게 생각해보지 않았다.
- 하지만 궁수가(5,2)에 위치하고 적이(4,4), (3,1)에 위치할 때 (4,4)에 위치한 적을 타겟팅하여 반례가 생겼다.
- 문제의 모든 조건을 꼼꼼하게 따져봐야겠다.

--- 

# 문제 풀이

## [Baekjoon] 17070_파이프옮기기1

### 문제 링크 : [https://www.acmicpc.net/problem/17070](https://www.acmicpc.net/problem/17070)

### 알고리즘 : DFS

### 풀이방법

- 파이프를 밀 때 새로 차지하게 되는 공간에 벽이 있는지, N,N위치에 도착했는지 확인했다.
- 가로 파이프는 -, \ 형태로 밀 수 있다.
- 세로 파이프는 |, \ 형태로 밀 수 있다.
- 대각선 파이프는 -, |, \ 형태로 밀 수 있다.
- 따라서 모든 형태의 파이프는 \ 형태가 될 수 있다.
- 또한 가로, 대각선 형태의 파이프는 - 형태가 될 수 있다.
- 또한 세로, 대각선 형태의 파이프는 | 형태가 될 수 있다.
- 위 조건을 바탕으로 시작점 (0,1)에서 가로 형태를 0, 세로 형태를 1, 대각선 형태를 2로 치환하여 DFS를 수행한다.

---

# 문제 풀이

## [Baekjoon] 17417_게리멘더링

### 문제 링크 : [https://www.acmicpc.net/problem/17471](https://www.acmicpc.net/problem/17417)

### 알고리즘 : DFS,BFS

### 풀이방법

- DFS를 통해 선거구가 나누어지는 모든 경우의 수를 구한다.
- DFS를 통해 나누어진 선거구를 BFS를 통해 선거구 내의 지역이 서로 연결되어있는지 판별한다.
- 위 조건이 모두 만족되면 두 선거구의 인구수 차이를 계산하여 최소화한다.

### 이슈사항

- DFS를 depth 1~6까지 전부 계산했더니 시간초과가 발생했다.
- 조금 깊이 생각해보니 선거구1(1,2,3)과 선거구2(4,5,6)인 경우가 선거구1(4,5,6),선거구2(1,2,3) 계산과
- 동일하기 때문에 DFS함수 호출을 절반으로 줄일 수 있었다. 

---

# 문제 풀이

## [Baekjoon] 14888_연산자 끼워넣기

### 문제 링크 : [https://www.acmicpc.net/problem/14888](https://www.acmicpc.net/problem/14888)

### 알고리즘 : DFS(조합)

### 풀이방법

- DFS를 통해 연산자가 배치되는 모든 조합을 구한다.
- 완성된 연산자 조합을 통해 주어진 숫자열을 계산한다.

### 이슈사항

- max_result 값을 0으로 설정하고 채점했는데 계속 실패가 떠서 의문이었다.
- 확인해보니 계산 결과 최대값이 음수일 때 max함수로 0이 저장되었다.
- 저번에도 코드리뷰로 float("inf") 사용을 권장받았었는데 귀찮아서 쓰지 않다가
- 이번에 고생해서 이제부터는 습관화 해야겠다.