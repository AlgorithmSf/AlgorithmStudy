## [Baekjoon] 14888\_연산자끼워넣기

### 알고리즘 : DFS

### 풀이방법

- 사칙연산의 순서는 고려하지 않는 것에 유의.
- 연산자를 고르는 시행을 DFS로 구현!
- DFS의 인자로 연산을 시행해줄 숫자의 인덱스와 각 연산자들의 남은 개수를 사용

---

## [Baekjoon] 15683\_감시

### 알고리즘 : DFS, 브루트포스

### 풀이방법

- cctv를 통해 구현할 수 있는 감시 방향의 경우의 수에 대해 방향벡터로 구현
- DFS 내부에서는 각 cctv가 가질 수 있는 경우의수를 하나씩 조합해 보는 방식으로 하여 깊이 탐색 진행
- 깊이 탐색 특성 상 모든 cctv가 탐색이 완료되었을 때 종료된다는 것에 유의
- DFS 내부에서 while문을 통해 감시 방향으로 감시가 되었음을 표시하는데, 벽을 만날 때는 종료 되도록 조건을 걸어줌
- DFS를 넘겨줄 때 적용된 경우의 수의 cctv맵을 deepcopy하여 넘겨줌

---

## [Baekjoon] 17070\_파이프옮기기1

### 알고리즘 : BFS/DFS, DP

### 풀이방법

- 기본적으로 BFS와 DFS를 통해 푸는 문제.
- 조건에 유의하며 BFS든 DFS든 탐색을 진행하면 되지만 파이썬에 대한 실행시간이 매우 각박한(?) 이유로 시간초과 발생
- 결국 이보다 빠른 DP를 선택
- 해당 파이프를 배치하였을 때 이전에 놓여진 파이프들이 어떠한 경우의 수로 배치될 수 있을것인가를 생각.
- 이 때 대각선 이전에는 모든 파이프의 배치가 올 수 있음에 유의하며 대각선 파이프의 조건 또한 고려해야 함에 유의
- DP로 선뜻 생각하기 어려웠던 이유는 초기값이랄 것이 없다고 생각해서 였다. 그러다가 첫 파이프가 (0,1)에 놓여있다고 했음을 인지하게 되었고 이를 이용하여 DP로 사용할 수 있겠다고 생각할 수 있었음
- 문제를 잘 읽자.

---

## [Baekjoon] 17135\_캐슬디펜스

### 알고리즘 : 브루트포스(조합), 시뮬레이션

### 풀이방법

- 궁수가 위치할 수 있는 경우의 수를 combination을 활용하여 도출
- 몬스터가 모두 없어질 때까지 궁수 하나하나마다 쏠 수 있는 몬스터를 탐색
- 이때 쏘는 몬스터의 우선순위는 왼쪽에 있을 수록, 그리고 가장 가까이에 있을 수록 먼저 쏘게 됨.
- 따라서 같은 궁수가 같은 몬스터를 맞추는 경우도 있음.
- 위와 같은 조건들을 모두 만족하지 못할 시 테스트케이스를 절대 통과하지 못하기 때문에 반복문의 순서라던지 조건들에 유의하여야 함.
- 몬스터의 수 같은 경우에는 하기 나름이지만 visited를 탐색하여 남은 수를 탐색하기에는 많은 비용이 들기에 몬스터에 대한 카운트 변수를 생성함

---

## [Baekjoon] 17471\_게리맨더링

### 알고리즘 : 브루트포스(조합), BFS, 그래프

### 풀이방법

- 그래프에 대한 입력을 리스트로 받을지 행렬로 받을지 결정해야 함.
- 나는 행렬로 받았으며 직관적으로 인덱스를 찾아가 확인할 수 있다는 장점이 있음.
- 이 때 만들어질 수 있는 경우의 수를 조합으로 모두 생성할 수 있는데, 부분집합을 만들어야 하기 때문에 1가지를 고르는 경우의 수부터 n-1가지를 고르는 경우의 수 모두 호출하여 case 리스트에 저장.
- 백준 14889\_스타트와 링크 << 문제와 마찬가지로 0번째 인덱스는 -1번째 인덱스와, 1번째 인덱스는 -2번째 인덱스와 매칭되기 때문에 이와 같이 경우의 수를 분리하여 A팀과 B팀으로 나누었음.
- BFS는 그래프 방문에 대한 BFS와 같이 탐색해주면 되며, 방문하지 않았고 간선이 존재하며 해당 팀에 포함되는 노드(자치구)에 대해 계속 넣어주면서 탐색을 진행함.
- 간혹 나눈 팀에 대해 간선이 제대로 연결되지 않은 경우도 있어 이를 확인할 방법을 생각해보다가 탐색한 노드의 개수를 통해 확인하면 되겠다 싶어 BFS내부에서 개수를 세도록 하였음.
- 전체 노드 개수와 A팀의 BFS 결과 개수 + B팀의 BFS 결과 개수가 같다면 알맞게 분리된 것이기 때문에 이에 대한 인구수의 차이를 구하고 최소값과 비교하여 최신화시켰음.
