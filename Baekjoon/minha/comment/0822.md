## 14888_연산자끼워넣기
1. 입력받은 각 연산자의 횟수만큼 해당 연산자를 리스트에 넣는다.
2. 연산자 리스트에서 N-1개의 순열 리스트를 뽑아낸다.
3. 연산자 순열 리스트에서 한 개씩 계산을 수행하고, 결과를 res 리스트에 넣는다.
4. res 리스트에서 최댓값, 최솟값 출력

ps. 통과는 했지만.. 시간이랑 메모리가 완전 박살났다. 더 좋은 방법이 있을까..?

## 17070_파이프옮기기
![IMG_0588](https://user-images.githubusercontent.com/49333608/185776334-e22f97ae-9855-49eb-ac80-3efd5f7bfb03.jpg)
도저히 감이 안잡혀서 블로그 참고.. 세상엔 천재들이 많다..;(

## 15683_감시
1. 입력 받은 리스트에서 cctv에 대한 정보 y좌표, x좌표, 몇번 cctv인지를 cctv리스트에 저장
2. 각 cctv별 가능한 경우의 수(회전해서) rot에 저장
3. 0번 cctv부터 dfs 실행 <br>
3-1. cctv가 회전 가능한 경우의 수만큼 감시할 수 있는 곳의 값을 #로 바꾸고 다음 cctv 확인 <br>
3-2. 만약 마지막 cctv까지 확인을 했다면 office 리스트에서 0이 몇개인지 카운트해 현재 최소값과 비교 <br>
   
## 17471_게리맨더링
1. 0~N-1의 도시를 1개부터 n//2개로 combination 계산한 것을 groupA에 넣는다
2. groupA의 요소 한개씩 반복문을 돌며 set 연산으로 groupA에 속하지 않은 것을 b로 설정한다
3. a와 b 각각 그래프 탐색을 한다<br>
3-1. bfs로 그래프 탐색을 하며 큐가 빌 때까지 노드가 매개변수로 받은 도시에 속하는 경우 큐에 해당 도시를 넣는다<br>
   3-2. 과정 중에 큐에서 노드를 꺼낼 때 인구수를 더한다<br>
   3-3. 탐색을 마치면 인구 총합과 탐색한 노드의 개수를 리턴한다<br>
   
4. a와 b에서 리턴 받은 노드의 개수를 합한 것이 N개(전체 도시의 수)가 되면 두 곳의 인구 차이를 현재 최소값과 비교해 갱신한다

## 17135_캐슬디펜스
1. 궁수 3명의 위치(열만 지정) combination으로 구함
2. combination의 각각의 경우에 대해 공격하고 이동하는 과정 실행, 공격하는 함수에서 공격한 적의 수를 리턴 받아 combination 경우 별로 적의 수 비교
3. attack 함수<br>
3-1. 그래프 탐색하며 적이 존재하는 경우 거리를 구하고, 그 거리가 공격 제한 거리보다 작거나 같다면 적의 좌표와 거리를 target 리스트에 넣기<br>
   3-2. 그래프 탐색이 끝나면 target 리스트를 거리순, 열 번호 순으로 정렬<br>
   3-3. 정렬한 target 리스트에서 가장 앞의 요소가 공격 대상.. <br>
   3-4. 해당 좌표에 적이 존재하는 경우 값을 0으로 바꾸고 cnt 증가 -> if문 안쓰면 여러 궁수가가 같은 적을 공격하는 경우 cnt가 중복으로 증가<br>
   +) 18줄 if문 아래에 깂을 바꾸고 cnt를 증가하는 로직을 넣으려 했으나 에러가 나서 따로 리스트로 모아서 처리함.. 왜지?
   
4. 모든 궁수가 공격을 하면 cnt 리턴