## 14888_연산자끼워넣기
1. 입력받은 각 연산자의 횟수만큼 해당 연산자를 리스트에 넣는다.
2. 연산자 리스트에서 N-1개의 순열 리스트를 뽑아낸다.
3. 연산자 순열 리스트에서 한 개씩 계산을 수행하고, 결과를 res 리스트에 넣는다.
4. res 리스트에서 최댓값, 최솟값 출력

ps. 통과는 했지만.. 시간이랑 메모리가 완전 박살났다. 더 좋은 방법이 있을까..?

## 17070_파이프옮기기
![IMG_0588](https://user-images.githubusercontent.com/49333608/185776334-e22f97ae-9855-49eb-ac80-3efd5f7bfb03.jpg)

## 15683_감시
1. 입력 받은 리스트에서 cctv에 대한 정보 y좌표, x좌표, 몇번 cctv인지를 cctv리스트에 저장
2. 각 cctv별 가능한 경우의 수(회전해서) rot에 저장
3. 0번 cctv부터 dfs 실행 <br>
3-1. cctv가 회전 가능한 경우의 수만큼 감시할 수 있는 곳의 값을 #로 바꾸고 다음 cctv 확인 <br>
3-2. 만약 마지막 cctv까지 확인을 했다면 office 리스트에서 0이 몇개인지 카운트해 현재 최소값과 비교 <br>
   
## 17471_게리맨더링
1. 0~N-1의 도시를 1개부터 n//2개로 combination 계산한 것을 groupA에 넣는다
2. groupA의 요소 한개씩 반복문을 돌며 set 연산으로 groupA에 속하지 않은 것을 b로 설정한다
3. a와 b 각각 그래프 탐색을 한다<br>
3-1. bfs로 그래프 탐색을 하며 큐가 빌 때까지 노드가 매개변수로 받은 도시에 속하는 경우 큐에 해당 도시를 넣는다<br>
   3-2. 과정 중에 큐에서 노드를 꺼낼 때 인구수를 더한다<br>
   3-3. 탐색을 마치면 인구 총합과 탐색한 노드의 개수를 리턴한다<br>
   
4. a와 b에서 리턴 받은 노드의 개수를 합한 것이 N개(전체 도시의 수)가 되면 두 곳의 인구 차이를 현재 최소값과 비교해 갱신한다