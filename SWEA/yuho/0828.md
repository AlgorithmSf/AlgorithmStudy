## [SWEA] No.1\_낚시터자리잡기

### 알고리즘 : 순열, DFS

### 풀이방법

- 처음에는 BFS로 해보려고 했는데, BFS로는 마지막 한 사람이 들어 가야 하는데 왼쪽과 오른쪽이 모두 빈 경우를 따지기가 쉽지 않았음
- 이에 DFS로 변경하여 풀이하였음
- 게이트의 탐색 순서에 대해서 순열을 사용하여 모든 경우의 수를 탐색하는 방법을 사용함
- 한 가지 경우의 수가 주어졌을 때 해당 경우의 수의 앞부터 게이트 탐색을 시작하여 DFS를 통해 다음 게이트를 탐색하는 과정
- 마지막 한 사람이 들어 가야 하는데 왼쪽과 오른쪽이 모두 빈 경우를 따지는 것이 해당 문제의 핵심이라고 생각함!

---

## [SWEA] No.2\_헌터

### 알고리즘 : 순열, 시뮬레이션

### 풀이방법

- 몬스터, 고객 상관 없이 탐색하는 모든 방문 경우의 수를 순열을 통해 구한 후 하나씩 탐색 시작
- 주어진 경우의 수의 순서에 맞게 탐색을 진행하였으며 조건문을 통해 무의미한 시행은 종료되도록 함.
- 여기서 무의미한 시행이란 고객에게 방문했는데, 원하는 몬스터가 사냥한 몬스터 리스트에 없는 경우와 첫 방문을 고객에게 하는 경우.
- 조건에 걸리지 않고 탐색을 진행할 수 있다면 사냥꾼과 해당 위치 사이의 유클리드 거리를 구하여 전체 거리에 더해준 후 사냥꾼을 해당 위치로 이동

---

## [SWEA] No.3_Shuffle_O_Matic

### 알고리즘 : 브루트포스(재귀)

### 풀이방법

- x가 0~n-1의 종류로 섞일 수 있으므로 카드패를 섞는 시행을 기준으로 하여 재귀탐색 실행
- 여기서 x가 0인 경우는 이전 카드패와 그대로이기 때문에 무의미한 시행이므로 배제시킴
- 해당 문제의 핵심은 '셔플에 대한 코드를 어떻게 작성하였는가?' 인 듯함.
- x가 커질 때마다 카드패가 서로 조금씩 겹쳐지며 구성되는 구조라는 것은 알겠으나 이를 코드로 풀어내는 데에는 쉽지 않았음.
- 예시에서 나온 n=6일 때 뿐만 아니라 n=10일 때와 같은 카드 개수가 다른 상황에서 x에 따른 셔플 상태를 직접 써보면서 구현하는 것이 도움됨.
- DFS 탐색 도중 조건을 이용하여 가지치기를 할 수 있는 백트래킹을 사용할 수 있다면 시간이 더 단축될 것으로 예상
